<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yukai.tech","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="yukai的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Yukai&#39;s Blog">
<meta property="og:url" content="http://yukai.tech/index.html">
<meta property="og:site_name" content="Yukai&#39;s Blog">
<meta property="og:description" content="yukai的Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yukai">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yukai.tech/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yukai's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yukai's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2023/03/07/%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%99%B6%E5%9C%86%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%99%B6%E5%9C%86%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" class="post-title-link" itemprop="url">半导体晶圆知识积累</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-07 16:03:04" itemprop="dateCreated datePublished" datetime="2023-03-07T16:03:04+08:00">2023-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-13 10:18:27" itemprop="dateModified" datetime="2023-03-13T10:18:27+08:00">2023-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IC/" itemprop="url" rel="index"><span itemprop="name">IC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Fabless、Foundry、IDM"><a href="#1-Fabless、Foundry、IDM" class="headerlink" title="1. Fabless、Foundry、IDM"></a>1. Fabless、Foundry、IDM</h3><p>半导体行业根据生产设计以及制造能力分为不同的公司种类，分别是Fabless， Foundry和IDM。</p>
<ul>
<li><strong>Fabless</strong></li>
</ul>
<p>Fabless 指的只从事芯片设计与销售，不从事生产的公司，这样的企业被成为“无厂化企业”，手机厂商中的华为、苹果和小米，还有高通和联发科，都属于 Fabless。</p>
<p>目前大多数的芯片公司基本都是Fabless，也就是大家只负责芯片的开发设计，然后生产可以找专业的代工厂进行生产。芯片的开发设计是一个需要大量人力进行创新的领域，相对于生产设计投入成本相对较小，但是收益周期会更快。因此更多的公司只会选择开发设计这一块来做。</p>
<ul>
<li><strong>Foundry</strong></li>
</ul>
<p>Foundry 是能够自行完成芯片制造，但是没有设计能力的厂商，就是我们所熟知的代工厂。台积电就是典型的 Foundry，专注芯片制造，发展相关的工艺和制程，所以 Foundry 厂商其实就是 Fabless 厂商的代工方。</p>
<ul>
<li><strong>IDM</strong></li>
</ul>
<p>IDM 就是指既能够自行设计、也能够自行生产的芯片厂商，世界上有这种能力的不多，三星和英特尔。</p>
<h3 id="2-半导体集成电路和晶圆有何关系"><a href="#2-半导体集成电路和晶圆有何关系" class="headerlink" title="2. 半导体集成电路和晶圆有何关系?"></a>2. <strong>半导体集成电路和晶圆有何关系?</strong></h3><p>半导体集成电路是将很多元件集成到一个芯片内， 以处理和储存各种功能的电子部件。 </p>
<p>晶圆是指将硅(Si)、砷化镓(GaAs)等生成的单 晶柱切成薄片的圆盘。大部分晶圆都是由沙子中提 取的硅制成的。地球上有大量的硅,可以稳定供应, 并且硅具有无毒、环保的特点。</p>
<p>由于半导体集成电路是通过在晶圆的薄基板上制造多个相同电路而产生的， 因此晶圆是半导体的基础， 就像盖房子打地基一样。</p>
<h3 id="3-半导体晶圆制造工艺"><a href="#3-半导体晶圆制造工艺" class="headerlink" title="3. 半导体晶圆制造工艺"></a>3. 半导体晶圆制造工艺</h3><p><img src="/images/%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%99%B6%E5%9C%86%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/image-20230309135720606.png" alt="image-20230309135720606"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/03/07/%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%99%B6%E5%9C%86%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/30/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-BiSeNet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-BiSeNet/" class="post-title-link" itemprop="url">轻量级语义分割网络--BiSeNet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-30 15:31:51" itemprop="dateCreated datePublished" datetime="2022-12-30T15:31:51+08:00">2022-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-13 10:18:39" itemprop="dateModified" datetime="2023-03-13T10:18:39+08:00">2023-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/" itemprop="url" rel="index"><span itemprop="name">deep learning</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/Semantic-Segmentation/" itemprop="url" rel="index"><span itemprop="name">Semantic Segmentation</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-BiSeNet/image-20221230153835324.png" alt="image-20221230153835324"></p>
<p>BiSeNet出自旷世，于ECCV2018发表，实时语义分割的双向网络。</p>
<p>paper name : BiSeNet: Bilateral Segmentation Network for Real-time Semantic Segmentation</p>
<h3 id="1-要解决的问题"><a href="#1-要解决的问题" class="headerlink" title="1.  要解决的问题"></a>1.  要解决的问题</h3><ul>
<li>解决之前一些轻量级语义分割算法在做算法加速时<strong>损失空间信息</strong>或者<strong>感受野缩小</strong>的问题。</li>
</ul>
<h3 id="2-采用的方法"><a href="#2-采用的方法" class="headerlink" title="2. 采用的方法"></a>2. 采用的方法</h3><ul>
<li><p>提出双向（两条路）网络， 一条<strong>Spatial Path（SP）</strong>， 使用Conv(stride = 2)3次，获得原图1/8尺寸的特征图，保留较为丰富的空间特征信息(较多的channel, 较浅的网络)。另一条<strong>Context Path（CP）</strong>,译为上下文路径， 可以使用任意的轻量级网络，如Xception、ShuffleNet、MobileNet， 文中在 Xception 尾部附加一个全局平均池化层，其中感受野是 backbone 网络的最大值。 </p>
</li>
<li><p>两条网络提取的特征通过特征融合模块（Feature Fusion Module）来快速合并。</p>
</li>
</ul>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li>在 Cityscapes，CamVid 和 COCO-Stuff 数据集上达到了准确率和速度的平衡。</li>
</ul>
<p><img src="/images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-BiSeNet/image-20221230163614657.png" alt="image-20221230163614657"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/12/30/%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%BD%91%E7%BB%9C-BiSeNet/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/26/RocketMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/26/RocketMQ/" class="post-title-link" itemprop="url">RocketMQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-26 16:20:58" itemprop="dateCreated datePublished" datetime="2022-12-26T16:20:58+08:00">2022-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-28 17:34:40" itemprop="dateModified" datetime="2022-12-28T17:34:40+08:00">2022-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ 是阿里捐赠给Apache的一款低延迟、高并发、高可用、高可靠的分布式消息中间件， 经历过淘宝多次双十一的考验，RocketMQ既可为分布式应用系统提供异步解耦和削峰填谷的能力，同时也具备互联网应用所需的海量消息堆积、高吞吐、可靠重试等特性。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li>Topic: 消息主题， 一级消息类型， 生产者向其发送消息。</li>
<li>Message: 生产者向Topic发送并最终传送给消费者的数据消息的载体。</li>
<li>消息属性：生产者可以为消息定义的属性，包含Message Key和Tag。</li>
<li><strong>Message Key</strong>：消息的业务标识，由消息生产者（Producer）设置，唯一标识某个业务逻辑。</li>
<li><strong>Message ID</strong>：消息的全局唯一标识，由消息队列RocketMQ系统自动生成，唯一标识某条消息。</li>
<li><p><strong>Tag</strong>：消息标签，二级消息类型，用来进一步区分某个Topic下的消息分类</p>
</li>
<li><p><strong>Producer</strong>：也称为消息发布者，负责生产并发送消息至Topic。</p>
</li>
<li><strong>Consumer</strong>：也称为消息订阅者，负责从Topic接收并消费消息。</li>
<li><strong>Group</strong>：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。</li>
<li><strong>Group ID</strong>：Group的标识。</li>
<li><strong>队列</strong>：Topic下会由一到多个队列来存储消息。</li>
<li><strong>Exactly-Once投递语义</strong>：Exactly-Once投递语义是指发送到消息系统的消息只能被Consumer处理且仅处理一次，即使Producer重试消息发送导致某消息重复投递，该消息在Consumer也只被消费一次。</li>
<li><strong>集群消费</strong>：一个Group ID所标识的所有Consumer平均分摊消费消息。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在集群消费模式下每个实例平均分摊，只消费其中的3条消息。</li>
<li><strong>广播消费</strong>：一个Group ID所标识的所有Consumer都会各自消费某条消息一次。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在广播消费模式下每个实例都会各自消费9条消息。</li>
<li><strong>定时消息</strong>：Producer将消息发送到消息队列RocketMQ服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到Consumer进行消费，该消息即定时消息。</li>
<li><strong>延时消息</strong>：Producer将消息发送到消息队列RocketMQ服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到Consumer进行消费，该消息即延时消息。</li>
<li><p><strong>顺序消息</strong>：RocketMQ提供的一种按照顺序进行发布和消费的消息类型，分为全局顺序消息和分区顺序消息。</p>
</li>
<li><p><strong>消息堆积</strong>：Producer已经将消息发送到消息队列RocketMQ的服务端，但由于Consumer消费能力有限，未能在短时间内将所有消息正确消费掉，此时在消息队列RocketMQ的服务端保存着未被消费的消息，该状态即消息堆积。</p>
</li>
<li><strong>消息过滤</strong>：Consumer可以根据消息标签（Tag）对消息进行过滤，确保Consumer最终只接收被过滤后的消息类型。消息过滤在消息队列RocketMQ的服务端完成。</li>
<li><strong>消息轨迹</strong>：在一条消息从Producer发出到Consumer消费处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从Producer发出，经由消息队列RocketMQ服务端，投递给Consumer的完整链路，方便定位排查问题。</li>
</ul>
<h3 id="消息收发模型"><a href="#消息收发模型" class="headerlink" title="消息收发模型"></a>消息收发模型</h3><p>消息队列RocketMQ支持发布和订阅模型，消息生产者应用创建Topic并将消息发送到Topic。消费者应用创建对Topic的订阅以便从其接收消息。通信可以是一对多（扇出）、多对一（扇入）和多对多。具体通信如下图所示。</p>
<p><img src="/images/RocketMQ/image-20221228150138473.png" alt="image-20221228150138473"></p>
<ul>
<li><p><strong>生产者集群</strong>：用来表示发送消息应用，一个生产者集群下包含多个生产者实例，可以是多台机器，也可以是一台机器的多个进程，或者一个进程的多个生产者对象。<br>一个生产者集群可以发送多个Topic消息。发送分布式事务消息时，如果生产者中途意外宕机，消息队列RocketMQ服务端会主动回调生产者集群的任意一台机器来确认事务状态。</p>
</li>
<li><p><strong>消费者集群</strong>：用来表示消费消息应用，一个消费者集群下包含多个消费者实例，可以是多台机器，也可以是多个进程，或者是一个进程的多个消费者对象。<br>一个消费者集群下的多个消费者以均摊方式消费消息。如果设置的是广播方式，那么这个消费者集群下的每个实例都消费全量数据。</p>
<p>一个消费者集群对应一个Group ID，一个Group ID可以订阅多个Topic，如上图中的Group 2所示。Group和Topic的订阅关系可以通过直接在程序中设置即可。</p>
</li>
</ul>
<h3 id="系统部署架构"><a href="#系统部署架构" class="headerlink" title="系统部署架构"></a>系统部署架构</h3><p><img src="/images/RocketMQ/image-20221228150451882.png" alt="image-20221228150451882"></p>
<p>系统部署架构如上图所示， 图中设计到的几个概念：</p>
<ul>
<li><strong>Name Server</strong>：是一个几乎无状态节点，可集群部署，在消息队列RocketMQ版中提供命名服务，更新和发现Broker服务。</li>
<li><strong>Broker</strong>：消息中转角色，负责存储消息，转发消息。分为Master Broker和Slave Broker，一个Master Broker可以对应多个Slave Broker，但是一个Slave Broker只能对应一个Master Broker。Broker启动后需要完成一次将自己注册至Name Server的操作；随后每隔30s定期向Name Server上报Topic路由信息。</li>
<li><strong>生产者</strong>：与Name Server集群中的其中一个节点（随机）建立长链接（Keep-alive），定期从Name Server读取Topic路由信息，并向提供Topic服务的Master Broker建立长链接，且定时向Master Broker发送心跳。</li>
<li><strong>消费者</strong>：与Name Server集群中的其中一个节点（随机）建立长连接，定期从Name Server拉取Topic路由信息，并向提供Topic服务的Master Broker、Slave Broker建立长连接，且定时向Master Broker、Slave Broker发送心跳。Consumer既可以从Master Broker订阅消息，也可以从Slave Broker订阅消息，订阅规则由Broker配置决定。</li>
</ul>
<h3 id="RocketMQ的优缺点"><a href="#RocketMQ的优缺点" class="headerlink" title="RocketMQ的优缺点"></a>RocketMQ的优缺点</h3><p>RocketMQ优点：</p>
<ul>
<li>单机吞吐量：十万级</li>
<li>可用性：非常高，分布式架构</li>
<li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li>
<li>功能支持：MQ功能较为完善，分布式，扩展性好</li>
<li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li>
<li>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li>
<li><strong>RoketMQ</strong>在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验</li>
</ul>
<p>RocketMQ缺点：</p>
<ul>
<li>支持的客户端语言不多，目前是java及c++，其中c++不成熟</li>
<li>社区活跃度不是特别活跃那种</li>
<li>没有在 mq 核心中去实现<strong>JMS</strong>等接口，有些系统要迁移需要修改大量代码</li>
</ul>
<h3 id="rocketmq-client-python"><a href="#rocketmq-client-python" class="headerlink" title="rocketmq-client-python"></a>rocketmq-client-python</h3><p> 示例code</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Producer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span>(<span class="params">message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    向云端producer集群发送消息体</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ret = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#message = &#123;&quot;id&quot;:&quot;test_id&quot;,&quot;name&quot;:&quot;test_name&quot;,&quot;message&quot;:&quot;test_message&quot;&#125;</span></span><br><span class="line">        message = json.dumps(message).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="comment"># global reply</span></span><br><span class="line">        lock_reply.acquire()</span><br><span class="line">        producer = Producer(producer_name)</span><br><span class="line">        producer.set_namesrv_addr(namesrv_addr)</span><br><span class="line">        producer.set_session_credentials(session_credentials_name, session_credentials_password, <span class="string">&#x27;ALIYUN&#x27;</span>)</span><br><span class="line">        <span class="comment"># For ip and port name server address, use `set_namesrv_addr` method, for example:</span></span><br><span class="line">        <span class="comment"># producer.set_namesrv_addr(&#x27;127.0.0.1:9887&#x27;)</span></span><br><span class="line">        producer.start()</span><br><span class="line">        reply = Message(web_message_name)  <span class="comment"># web_message_name topic of message (WEBServer) #topic名称</span></span><br><span class="line">        reply.set_keys(<span class="string">&#x27;XXX&#x27;</span>)<span class="comment">#每个消息在业务层面的唯一标识码，要设置到keys字段，方便将来定位消息丢失问题。服务         器会为每个消息创建索引（哈希索引），应用可以通过topic，key来查询这条消息内容，以及消息被谁消费。由于是           哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。</span></span><br><span class="line">        reply.set_body(message)</span><br><span class="line">        reply.set_tags(<span class="string">&#x27;&#x27;</span>)<span class="comment">#一个应用尽可能用一个Topic，消息子类型用tags来标识，tags可以由应用自由设置。只有发         送消息设置了tags，消费方在订阅消息时，才可以利用tags在broker做消息过滤。</span></span><br><span class="line">        ret = producer.send_sync(reply)</span><br><span class="line">        producer.shutdown()</span><br><span class="line">        lock_reply.release()</span><br><span class="line">        ret = <span class="string">&quot;send message right&quot;</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        producer.shutdown()</span><br><span class="line">        lock_reply.release()</span><br><span class="line">        need_reconnected = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;send message error:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        ret = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PushConsumer</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> rocketmq.client <span class="keyword">import</span> PushConsumer</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(msg.<span class="built_in">id</span>, msg.body)</span><br><span class="line">consumer = PushConsumer(<span class="string">&#x27;CID_XXX&#x27;</span>)</span><br><span class="line">consumer.set_namesrv_domain(<span class="string">&#x27;http://onsaddr-internet.aliyun.com/rocketmq/nsaddr4client-internet&#x27;</span>)</span><br><span class="line"><span class="comment"># For ip and port name server address, use `set_namesrv_addr` method, for example:</span></span><br><span class="line"><span class="comment"># consumer.set_namesrv_addr(&#x27;127.0.0.1:9887&#x27;)</span></span><br><span class="line">consumer.set_session_credentials(<span class="string">&#x27;XXX&#x27;</span>, <span class="string">&#x27;XXXX&#x27;</span>, <span class="string">&#x27;ALIYUN&#x27;</span>)</span><br><span class="line">consumer.subscribe(<span class="string">&#x27;YOUR-TOPIC&#x27;</span>, callback)</span><br><span class="line">consumer.start()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">3600</span>)</span><br><span class="line">consumer.shutdown()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PullConsumer</span></span><br><span class="line"><span class="keyword">from</span> rocketmq.client <span class="keyword">import</span> PullConsumer</span><br><span class="line">consumer = PullConsumer(<span class="string">&#x27;CID_XXX&#x27;</span>)</span><br><span class="line">consumer.set_namesrv_domain(<span class="string">&#x27;http://onsaddr-internet.aliyun.com/rocketmq/nsaddr4client-internet&#x27;</span>)</span><br><span class="line"><span class="comment"># For ip and port name server address, use `set_namesrv_addr` method, for example:</span></span><br><span class="line"><span class="comment"># consumer.set_namesrv_addr(&#x27;127.0.0.1:9887&#x27;)</span></span><br><span class="line">consumer.set_session_credentials(<span class="string">&#x27;XXX&#x27;</span>, <span class="string">&#x27;XXXX&#x27;</span>, <span class="string">&#x27;ALIYUN&#x27;</span>)</span><br><span class="line">consumer.start()</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer.pull(<span class="string">&#x27;YOUR-TOPIC&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(msg.<span class="built_in">id</span>, msg.body)</span><br><span class="line">consumer.shutdown()</span><br></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/780968">https://developer.aliyun.com/article/780968</a></li>
<li><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/440186.html">https://help.aliyun.com/document_detail/440186.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94662788">https://zhuanlan.zhihu.com/p/94662788</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/400804837">https://zhuanlan.zhihu.com/p/400804837</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-title-link" itemprop="url">中间件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-26 15:35:27 / 修改时间：16:15:39" itemprop="dateCreated datePublished" datetime="2022-12-26T15:35:27+08:00">2022-12-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前段时间，在做深度学习训练平台时有用到RocketMQ这个分布式消息中间件， 自己对<strong>中间件</strong>（Middleware）基础概念还不是很清晰， 这里记录学习下。</p>
<p> <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240">百度百科</a>上的描述：</p>
<blockquote>
<p>中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能）， 衔接网络上应用系统的各个部分或不同的应用， 能够达到资源共享，功能共享的目的。</p>
<p>定义： 中间件是一种独立的系统软件服务程序， 分布式应用软件借助这种软件在不同的技术之间共享资源， 中间件位于客户机服务器的操作系统之上管理计算资源和网络通信。</p>
<p>中间件 = 平台  +   通信</p>
<p>中间件（基本功能）提供 1. 通信支持， 2. 应用支持,  3.公共服务</p>
<p>中间件（基本分类）有 1. 事务式中间件   2，过程式中间件   3，<strong>面向消息的中间件</strong>  4，面向对象的中间件  5， Web应用服务器  6，其他</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19730582">知乎Gocy大佬的通俗性解释</a></p>
<blockquote>
<p>个人理解：<br>将具体业务和底层逻辑解耦的组件。</p>
<p>大致的效果是：<br>需要利用服务的人（前端写业务的），不需要知道底层逻辑（提供服务的）的具体实现，只要拿着中间件结果来用就好了。</p>
<p>举个例子：<br>我开了一家炸鸡店（业务端），然而周边有太多屠鸡场（底层），为了成本我肯定想一个个比价，再综合质量挑选一家屠鸡场合作（适配不同底层逻辑）。由于市场变化，合作一段时间后，或许性价比最高的屠鸡场就不是我最开始选的了，我又要重新和另一家屠鸡场合作，进货方式、交易方式等等全都要重来一套（重新适配）。</p>
<p>然而我只想好好做炸鸡，有性价比高的肉送来就行。于是我找到了一个专门整合屠鸡场资源的第三方代理（中间件），跟他谈好价格和质量后（统一接口），从今天开始，我就只需要给代理钱，然后拿肉就行。代理负责保证肉的质量，至于如何根据实际性价比，选择不同的屠鸡场，那就是代理做的事了。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19730582/answer/140527549">https://www.zhihu.com/question/19730582/answer/140527549</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19730582/answer/1768682017">知乎小傅哥的解答</a></p>
<blockquote>
<p>中间件用于解决共性凝练和复用</p>
</blockquote>
<p>Reference</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/middleware/what-is-middleware">https://www.redhat.com/zh/topics/middleware/what-is-middleware</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240">https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19730582">https://www.zhihu.com/question/19730582</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/22/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">python设计模式--生产者消费者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-22 17:28:55" itemprop="dateCreated datePublished" datetime="2022-12-22T17:28:55+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-26 15:03:39" itemprop="dateModified" datetime="2022-12-26T15:03:39+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-生产者消费者模式"><a href="#1-生产者消费者模式" class="headerlink" title="1. 生产者消费者模式"></a>1. 生产者消费者模式</h3><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。</p>
<p>生产者和消费者之间不直接通讯， 而是通过阻塞队列来进行通讯。</p>
<p>生产者生产完数据之后不用等待消费者处理， 直接扔给阻塞队列， 同理， 消费者也不找生产者要数据， 而是直接从阻塞队列中获取。</p>
<p>这里， 阻塞队列可以看做是一个缓冲区， 平衡了生产者和消费者的处理能力。</p>
<p><img src="/2022/12/22/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/image-20221222173718064.png" alt="image-20221222173718064"></p>
<h3 id="2-主要作用"><a href="#2-主要作用" class="headerlink" title="2. 主要作用"></a>2. 主要作用</h3><ul>
<li>解耦合</li>
<li>异步执行，提高程序的运行效率。</li>
</ul>
<h3 id="3-结构剖析"><a href="#3-结构剖析" class="headerlink" title="3. 结构剖析"></a>3. 结构剖析</h3><p>   在生产者-消费者模式中，通常有两类线程，一类是生产者线程一类是消费者线程。生产者线程负责提交用户请求，消费者线程则负责处理生产者提交的任务。</p>
<p>​    最简单粗暴的做法就是生产者每提交一个任务，消费者就立即处理，直到所有任务处理完。但是这样直接通信很容易出现性能上的问题，消费者必须等待它的生产者提交到任务才能执行，就不能达到真正的并行。同时生产者和消费者之间存在依赖关系，在设计上耦合度非常高，这是不可取的。那么最好的做法就是<strong>加一个中间层作为通信桥梁</strong>。</p>
<p><strong>生产者和消费者之间通过共享内存缓存区进行通信</strong>。多个生产者线程将任务提交给共享内存缓存区，消费者线程并不直接与生产者线程通信，而在共享内存缓冲区获取任务，并行地处理。其中内存缓冲区的主要功能是数据再多线程间的共享，同时还可以通过该缓存区，缓解生产者和消费者间的性能差。<strong>它是生产者消费者模式的核心组件，既能作为通信的桥梁，又能避免两者直接通信，从而将生产者和消费者进行解耦。</strong>生产者不需要消费者的存在，消费者也不需要知道生产者的存在。</p>
<p>例如在CV中， 取图线程（进程）通常比较快速， 计算线程（进程）通常较慢， 此时可以维护一个队列（共享内存缓冲区），设计为生产者消费者模式进行处理， 一个取图线程当做生产者， 多个计算线程当做消费者。</p>
<h3 id="4-code"><a href="#4-code" class="headerlink" title="4. code"></a>4. code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#定义一个生产者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>():</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;生产第%s个产品......&#x27;</span>,count)</span><br><span class="line">        q.put(count)</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    q.join()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#定义一个消费者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 消费第%s个产品&quot;</span> % (name,q.get()))</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;消费者执行完了所有任务&#x27;</span>)</span><br><span class="line"><span class="comment">#定义一个队列</span></span><br><span class="line">q = queue.Queue(maxsize=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=producer)</span><br><span class="line">t2 = threading.Thread(target=consumer,args=(<span class="string">&#x27;Consumer&#x27;</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">生产第%s个产品...... 0</span></span><br><span class="line"><span class="string">Consumer 消费第0个产品</span></span><br><span class="line"><span class="string">消费者执行完了所有任务</span></span><br><span class="line"><span class="string">生产第%s个产品...... 1</span></span><br><span class="line"><span class="string">Consumer 消费第1个产品</span></span><br><span class="line"><span class="string">消费者执行完了所有任务</span></span><br><span class="line"><span class="string">生产第%s个产品...... 2</span></span><br><span class="line"><span class="string">Consumer 消费第2个产品</span></span><br><span class="line"><span class="string">消费者执行完了所有任务</span></span><br><span class="line"><span class="string">生产第%s个产品...... 3</span></span><br><span class="line"><span class="string">Consumer 消费第3个产品</span></span><br><span class="line"><span class="string">消费者执行完了所有任务</span></span><br><span class="line"><span class="string">生产第%s个产品...... 4</span></span><br><span class="line"><span class="string">Consumer 消费第4个产品</span></span><br><span class="line"><span class="string">消费者执行完了所有任务</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/14/python-map-and-reduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/14/python-map-and-reduce/" class="post-title-link" itemprop="url">python map and reduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-14 16:54:28" itemprop="dateCreated datePublished" datetime="2022-12-14T16:54:28+08:00">2022-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-15 17:15:03" itemprop="dateModified" datetime="2022-12-15T17:15:03+08:00">2022-12-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>map 与 reduce函数</p>
<ol>
<li><p>map()函数接收两个参数， 第一个是函数， 第二个是Iterable， map将传入的函数依次作用到序列的每个元素， 并将结果作为新的Iterator返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">r = <span class="built_in">map</span>(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">squareed_list = <span class="built_in">list</span>(r)</span><br><span class="line"><span class="built_in">print</span>(squreed_list) <span class="comment"># [1,4,9,16,25]</span></span><br><span class="line"><span class="comment">#使用lambda匿名函数简化为一行代码</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>注意map函数返回的是一个Iterator(惰性序列)， 要通过list函数转化为常用列表结构。</p>
</li>
<li><p>reduce()函数接收两个参数， 一个是函数（两个参数）， 一个是序列， 与map不同的是，reduce把结果和序列的下一个元素做累积计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">CHAR_TO_INT = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    ints = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: CHAR_TO_INT[x], <span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: <span class="number">10</span>*x + y, ints)</span><br><span class="line"><span class="built_in">print</span>(str2int(<span class="string">&#x27;0012345&#x27;</span>)) <span class="comment"># 0012345</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/14/instance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/14/instance/" class="post-title-link" itemprop="url">python函数参数类型检查</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-14 16:01:04 / 修改时间：16:10:16" itemprop="dateCreated datePublished" datetime="2022-12-14T16:01:04+08:00">2022-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>python 实现对函数参数做类型检查</p>
<p>python自带的函数一般都会有对函数参数类型做检查，自定义的函数参数类型检查可以用函数isinstance()实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	自定义的绝对值函数</span></span><br><span class="line"><span class="string">	:param x: int or float</span></span><br><span class="line"><span class="string">	:return: positive number, int or float</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operated type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<p>添加了函数参数检查后，如果传入错误的参数类型， 函数就可以抛出一个TypeError错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/05/python-parameter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/05/python-parameter/" class="post-title-link" itemprop="url">Python 的函数参数传递</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-05 17:31:47" itemprop="dateCreated datePublished" datetime="2022-12-05T17:31:47+08:00">2022-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-14 15:00:55" itemprop="dateModified" datetime="2022-12-14T15:00:55+08:00">2022-12-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>将可变对象（mutable）：列表list，字典dict，Numpy数组ndarray和用户自定义类型（类class），作为参数传递给函数， 函数内部将其改变后， 函数外部这个变量也会改变。</li>
<li>将不可改变对象（immutable）：字符串string，元祖tuple，数值numbers，作为参数传递给函数，函数内部将其改变后，函数外部这个变量不会改变。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>使用id来看引用a的内存地址辅助理解一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;func_in&quot;</span>,<span class="built_in">id</span>(a)   <span class="comment"># func_in 41322472</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;re-point&quot;</span>,<span class="built_in">id</span>(a), <span class="built_in">id</span>(<span class="number">2</span>)   <span class="comment"># re-point 41322448 41322448</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;func_out&quot;</span>,<span class="built_in">id</span>(a), <span class="built_in">id</span>(<span class="number">1</span>)  <span class="comment"># func_out 41322472 41322472</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># 1 </span></span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;func_in&quot;</span>,<span class="built_in">id</span>(a)  <span class="comment"># func_in 53629256</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;func_out&quot;</span>,<span class="built_in">id</span>(a)     <span class="comment"># func_out 53629256</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/12/01/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/01/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/" class="post-title-link" itemprop="url">影响模型推理速度的几个关键因素</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-01 13:54:34" itemprop="dateCreated datePublished" datetime="2022-12-01T13:54:34+08:00">2022-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-02 18:10:29" itemprop="dateModified" datetime="2022-12-02T18:10:29+08:00">2022-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/" itemprop="url" rel="index"><span itemprop="name">deep learning</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/object-detection/" itemprop="url" rel="index"><span itemprop="name">object detection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记得刚工作的时候做摄像头端的灯语识别， 主要是未涂红状态下的各种信号灯的识别， 当时用一个resnet-50跑了下实验觉得还不错， 结果导师讲用不了这么“大”的模型， 让把这个大模型砍成一个小的， 似懂非懂，一顿操作， 换backbone，各种轻量级网络，shuffleNet，mobilenet一顿尝试，还不如直接把resnet砍几层好使， 在此学习记录下<strong>田子宸@知乎</strong>的文章。</p>
<h3 id="一-、模型”大小”评价指标"><a href="#一-、模型”大小”评价指标" class="headerlink" title="一 、模型”大小”评价指标"></a>一 、模型”大小”评价指标</h3><p>| 计算量 | 参数量 |访存量 |内存占用|</p>
<ol>
<li><p>计算量</p>
<p>计算量是模型所需的计算次数，反映了模型对硬件计算单元的需求。计算量一般用 <strong>OPs</strong> (Operations) ，即计算次数来表示。由于最常用的数据格式为 float32，因此也常常被写作 <strong>FLOPs</strong> (Floating Point Operations)，即浮点计算次数。<br>之前总结过卷积中的计算量 <a href="https://yukai.tech/2022/07/27/%E5%8D%B7%E7%A7%AF%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%87%8F%E3%80%81%E8%AE%A1%E7%AE%97%E9%87%8F/">计算量</a>。</p>
</li>
<li><p>参数量 </p>
<p>参数量是模型中的参数的总和，跟模型在磁盘中所需的空间大小直接相关。对于 CNN 来说参数主要由 Conv/FC 层的 Weight 构成。</p>
<p>参数量往往是被算作访存量的一部分，因此参数量不直接影响模型推理性能。但是参数量一方面会影响内存占用，另一方面也会影响程序初始化的时间。</p>
</li>
<li><p>访存量 （MACs memory access cost）</p>
<p><strong>访存量往往是最容易忽视的评价指标，但其实是现在的计算架构中对性能影响极大的指标。</strong></p>
<p>访存量是指模型计算时所需访问存储单元的字节大小，反映了模型对存储单元带宽的需求。访存量一般用 <strong>Bytes</strong>（或者 <strong>KB/MB/GB</strong>）来表示，即模型计算到底需要存/取多少 Bytes 的数据。</p>
<p>和计算量一样，模型整体访存量等于模型各个算子的访存量之和。对于 Eltwise Sum 来讲，两个大小均为 (N, C, H, W) 的 Tensor 相加，访存量是 (2 + 1) x N x C x H x W x sizeof(data_type)，其中 2 代表读两个 Tensor，1 代表写一个 Tensor；而对于卷积来说，访存量公式为：</p>
</li>
</ol>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221201155159400.png" alt="image-20221201155159400"></p>
<ol>
<li><p>内存占用</p>
<p>内存占用是指模型运行时，所占用的内存/显存大小。一般有工程意义的是最大内存占用，当然有的场景下会使用平均内存占用。这里要注意的是，内存占用 ≠ 访存量。</p>
<p>和参数量一样，内存占用不会直接影响推理速度，往往算作访存量的一部分。但在同一平台上有多个任务并发的环境下，如推理服务器、车载平台、手机 APP，往往要求内存占用可控。可控一方面是指内存/显存占用量，如果占用太多，其他任务就无法在平台上运行；另一方面是指内存/显存的占用量不会大幅波动，影响其他任务的可用性。</p>
</li>
</ol>
<h3 id="二、计算量越小，模型推理越快吗？"><a href="#二、计算量越小，模型推理越快吗？" class="headerlink" title="二、计算量越小，模型推理越快吗？"></a>二、计算量越小，模型推理越快吗？</h3><p> 答案是否定的。</p>
<p>实际上计算量和实际的推理速度之间没有直接的因果关系。计算量仅能作为模型推理速度的一个参考依据。</p>
<p><strong>模型在特定硬件上的推理速度，除了受计算量影响外，还会受访存量、硬件特性、软件实现、系统环境等诸多因素影响</strong>，呈现出复杂的特性。因此，在手头有硬件且测试方便的情况下，<strong>实测是最准确的性能评估方式</strong>。</p>
<p>在设计网络结构时，如果有实测的条件，建议在模型迭代早期对性能也进行测试。一些 NAS 的方法也会对搜索出来的网络结构进行测速，或者干脆对硬件速度进行了建模，也作为初期搜索的重要参数。这种方法设计出来的网络在后期部署时，会极大减少因性能问题迭代优化的时间和人力开销。</p>
<p>这里作者讨论影响模型在硬件上推理速度的一些因素，一方面希望可以帮助手动/自动设计网络结构的同学更快的设计更高效的网络结构，另一方面希望当模型部署时性能出现问题时能够为大家提供分析原因的思路。</p>
<ul>
<li>计算密度与 RoofLine 模型</li>
<li>计算密集型算子与访存密集型算子</li>
<li>推理时间</li>
</ul>
<ol>
<li><strong>计算密度与 RoofLine 模型</strong></li>
</ol>
<p>计算密度是指一个程序在单位访存量下所需的计算量， 单位是FLOPs/Byte， 也称计算访存比，用于反映一个程序相对于访存来说计算的密集程度：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221201175419410.png" alt="image-20221201175419410"></p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202104733290.png" alt="image-20221202104733290"></p>
<p><strong>RoofLine 模型</strong>是一个用于评估程序在硬件上能达到的<strong>性能上界</strong>的模型，可用上图表示：</p>
<p>RoofLine 模型</p>
<p>用公式描述：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202104836499.png" alt="image-20221202104836499"></p>
<p>当程序的计算密度I较小时， 程序访存多而计算少，性能受到内存贷款限制，称为<strong>访存密集型程序</strong>。即上图的橙色区域，。在此区域上的程序性能上界 = 计算密度 * 内存带宽， 表现为图中的斜线，其中斜率为内存带宽的大小。计算密度越大， 程序所能达到的速度上界越高，但使用的内存带宽始终为最大值。</p>
<p>反之如果计算密度I较大，程序性能受<strong>硬件最大计算峰值</strong>（下文简称为<strong>算力</strong>）限制，称为<strong>计算密集</strong>型程序，即图中蓝色区域。此时性能上界=硬件算力，表现为图中的横线。此时计算速度不受计算密度影响，但计算密度越大，所需内存带宽就越少。</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202142339938.png" alt="image-20221202142339938"></p>
<p>在不同设备上，同一个程序的性质可能发生变化</p>
<p><strong>在不同设备上，同一个程序的性质可能发生变化</strong>。例如上图中的程序2，在算力稍弱的设备2上属于计算密集型程序，而在算力较强的设备1上就属于访存密集型程序了。如果想要充分发挥设备1的性能，应当适当加大程序的计算密度（比如到程序3的位置）。</p>
<h3 id="2-计算密集型算子与访存密集型算子"><a href="#2-计算密集型算子与访存密集型算子" class="headerlink" title="2. 计算密集型算子与访存密集型算子"></a><strong>2. 计算密集型算子与访存密集型算子</strong></h3><p>网络中的算子可以根据计算密度进行分类。一般来讲，<strong>Conv、FC、Deconv 算子属于计算密集型算子；ReLU、EltWise Add、Concat 等属于访存密集型算子。</strong></p>
<p><strong>同一个算子也会因参数的不同而导致计算密度变化，甚至改变性质</strong>，比如在其他参数不变的前提下，增大 Conv 的 group，或者减小 Conv 的 input channel 都会减小计算密度。</p>
<p>举个栗子，对于不同参数的卷积，计算密度如下：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202142930054.png" alt="image-20221202142930054"></p>
<p>可以看到，不同参数下卷积算子的计算密度有很大的差异。第 4 个算子 Depthwise Conv 计算密度仅有 2.346，在当下的很多设备上都属于访存密集型算子。</p>
<p><strong>算子的计算密度越大，约有可能提升硬件的计算效率，充分发挥硬件性能</strong>。我们以一个 Intel X86 服务器平台为例（10980 XE）。该平台 CPU 频率为 4.5 GHz，我们以 16 核为例，其理论 FP32 算力为 4.608 TFLOPs/s，内存带宽理论值为 96 GB/s。在此平台上的 RoofLine 模型为：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202143039023.png" alt="image-20221202143039023"></p>
<p>Intel 10980 XE 16 核 RoofLine 模型，以及各个算子的计算密度与性能</p>
<p>该平台“拐点”的计算密度为 48，计算较为密集的 OP1 和 OP2 处在计算密集区，能够达到平台的算力峰值；而 OP3 和 OP4 处在访存密集区，受内存带宽限制不能到达算力峰值，尤其是 OP4，由于计算访存比过低，计算效率仅有可怜的 4.9%，计算效率并不高。</p>
<h3 id="3-推理时间"><a href="#3-推理时间" class="headerlink" title="3. 推理时间"></a><strong>3. 推理时间</strong></h3><p>这里涉及到一个 gap，很多部署的同学们更喜欢谈“计算效率”，而实际上算法同学真正关心的点是“推理时间”，导致两者在对接的时候经常会出现一些 misleading。因此我这里单独开一节来探讨一下“推理时间”的评估方法。</p>
<p>其实也很简单，按照 RoofLine 模型，我们很容易就能得到算子实际的执行时间：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202143439933.png" alt="image-20221202143439933"></p>
<p>这是一个分段函数，拆开来可得：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202143458717.png" alt="image-20221202143458717"></p>
<p>一句话总结：<strong>对于访存密集型算子，推理时间跟访存量呈线性关系，而对于计算密集型算子，推理时间跟计算量呈线性关系</strong>。</p>
<p>讲到这里，我们就能<strong>初步</strong>回答本章一开始的问题了(计算量越小，推理速度越快吗)：</p>
<p>按照 RoofLine 模型，<strong>在计算密集区，计算量越小，确实推理时间越小。但是在访存密集区，计算量与推理时间没关系，真正起作用的是访存量，访存量越小，推理的时间才越快。在全局上，计算量和推理时间并非具有线性关系</strong>。</p>
<p>上一节中，OP4 虽然计算效率很低，但由于访存量也很低，因此其实推理速度还是快于其他几个 OP 的。但是我们可以观察到，其计算量虽然只有 OP1 的 1/130，但是推理时间仅降低到了 1/6，两者并非是线性关系。</p>
<p>再举两个例子强化一下，首先看这两个卷积，他们的计算量差不多，但是因为都在访存密集区，OP3 的访存量远低于 OP5，其推理也更快：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202144542383.png" alt="image-20221202144542383"></p>
<p>下面这个栗子更明显，OP5 和 OP6 的区别仅仅是一个是 DepthWise Conv，一个是普通 Conv，其他参数没有变化。按照我们之前的直观感受，Conv 换成 DepthWise Conv 应该会更快，但实际上两者的推理时间是差不多的。</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202144717200.png" alt="image-20221202144717200"></p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a><strong>4. 小结</strong></h3><p>从上面的讨论中我们可以看出：<strong>计算量并不能单独用来评估模型的推理时间，还必须结合硬件特性（算力&amp;带宽），以及访存量来进行综合评估</strong>。并非是计算量越低模型推理越快。<strong>在评价模型大小时，也建议加上访存量作为重要的评价指标</strong>。</p>
<p>需要强调的一点是，不同的硬件平台峰值算力和内存带宽不同，导致同一个模型在平台 1 上可能是计算密集的，在平台 2 上可能就变成了访存密集的。例如上文提到的 Intel X86 平台，“拐点”值为 48，而 NVIDIA V100“拐点”值为 173.6，上文举的例子在 V100 平台上仅有 OP2 落在了计算密集区，剩下的全部是访存密集的。因此，<strong>同样的模型在不同平台上性质可能会发生改变</strong>，需要具体情况具体分析。</p>
<p>我们很难给出一个通用性的结论，究其原因是 RoofLine 模型本身是一个非线性模型。这里必须要强调一点的是，<strong>除了峰值算力和内存带宽之外，还有硬件限制、系统环境、软件实现等诸多因素会影响程序的实际性能，使得其非线性特性更加严重。因此 RoofLine 模型仅仅只能提供一个性能上界的评估方式，并不代表能够达到的实际性能。实际性能最准确的测量方式只有真机实测</strong>。</p>
<p>RoofLine 模型更重要的是提供了一种分析性能的思想，即计算密集型程序更多的受限于硬件算力，而访存密集型程序更多的受限于硬件内存带宽。在理解这一点的基础上设计网络结构，并分析网络的性能，将更有理论参考。不会再对”计算量减半，为啥推理时间没变“这种问题抱有疑问了。</p>
<h2 id="三、影响模型推理性能的其他因素"><a href="#三、影响模型推理性能的其他因素" class="headerlink" title="三、影响模型推理性能的其他因素"></a><strong>三、影响模型推理性能的其他因素</strong></h2><p>RoofLine 模型可以用来评估程序的性能上界，但是实际能达到的性能还会受到硬件限制、系统环境、软件实现等诸多因素的影响，距离性能上界有一定距离。本章将对这些影响因素进行分析。</p>
<p>前面 RoofLine 模型使用的峰值算力及内存带宽，是根据纸面数据计算得到的，是理论上的最大值。但在实际情况下，<strong>硬件会因为种种原因，无法达到这个理论值。因此建议大家对硬件进行micro-benchmark，以获取硬件的真实性能上限</strong>。</p>
<p>以上文的 Intel X86 CPU 为例，我们之前计算的 avx512 理论算力为 4.608 TFLOPs/s，但这个数值的前提是频率能维持在 4.5 GHz。然而实际上在使用 16 核跑 avx512 指令时，CPU 频率会下降到约 2.9 GHz，此时理论算力仅剩下 2.96 TFLOPs/s，而实测值仅有 2.86 TFLOPs/s。</p>
<p>除了频率之外，有些芯片可能会因为一些设计上或实现上的原因，导致在实际使用时达不到理论峰值。比如一些低端芯片不支持多发射、不支持乱序执行、采用了阻塞式 Cache 等等，一些芯片甚至会有一些性能 bug，导致在实际使用时几乎到达不了理论峰值（这里我个人倾向于把这些原因归结为硬件限制带来的损失）。</p>
<p>内存同理，该平台理论带宽为 96GB/s，但实测下来最高读带宽仅有 74 GB/s，仅能到达理论带宽的 77%。</p>
<p>我们可以得到修正后的 RoofLine 模型，图中蓝色填充部分反映了因实际算力和内存带宽达到不了理论值而造成的损失：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202145706361.png" alt="image-20221202145706361"></p>
<p>修正了实测峰值算力和内存带宽后的 RoofLine 模型，蓝色填充部分为硬件限制带来的损失</p>
<p>修正后的模型“拐点”发生了变化，因此算子的性质也会发生变化。</p>
<h3 id="2-系统环境对性能的影响"><a href="#2-系统环境对性能的影响" class="headerlink" title="2. 系统环境对性能的影响"></a><strong>2. 系统环境对性能的影响</strong></h3><p>除非程序运行在裸机中，否则操作系统一定会对性能上界产生一定影响，比如操作系统在多核间的调度损失、操作系统的内存管理带来的损失、操作系统本身占用的运算资源等等。</p>
<p>对于一般的深度学习推理任务而言，现代操作系统对性能的影响并不是特别明显。但是在一些特殊情况下，也会带来严重的性能损失。我这里将会举两个例子：</p>
<p>一个是 Android 系统在大小核上的调度，一旦程序在 CPU 上的占用率不足（比如是周期工作的任务），则有可能被 Android 调度到小核上，带来性能损失。</p>
<p>另一个例子是内存缺页。在 Linux 系统上，当向系统申请内存页后，系统只是返回了虚拟页，等到程序实际使用虚拟页时，才会通过触发缺页异常的方式，进入操作系统内核分配物理页，这一过程会严重降低性能。</p>
<p>好在这些问题可以通过软件进行一部分弥补，例如调度问题可以使用绑核来解决，缺页问题可以通过绑定物理页（需要内核态）或内存池来解决。因此操作系统带来的影响是可控的。</p>
<p>除了操作系统带来的影响，系统中运行的其他进程也会对当前进程造成影响。比如一个系统中运行了多个深度学习实例，或者系统后台一些 APP 自启动了等等。这些进程都会占用核心算力和内存带宽，造成当前进程性能损失。</p>
<p>这往往会导致在工程测试环境下性能达标的模型，在实际部署时性能下降。因此，<strong>必须关注工程测试环境和实际部署系统环境的差异</strong>。如有条件，最好在实际部署环境下进行测试。</p>
<h3 id="3-软件实现对性能的影响"><a href="#3-软件实现对性能的影响" class="headerlink" title="3. 软件实现对性能的影响"></a><strong>3. 软件实现对性能的影响</strong></h3><p>除了硬件限制和系统环境外，<strong>一个任务的软件实现好坏对性能有着重大的影响</strong>。</p>
<p>例如对于同样的矩阵操作任务，使用 python 写的多重 for 循环，和用 numpy 高度优化过的矩阵操作函数，性能可以差出 1~2 个数量级。</p>
<p>对于深度学习模型推理而言，推理框架对模型性能的影响主要体现在：是否充分利用了硬件的流水线资源、是否高效利用了硬件中的缓存、是否采用了时间复杂度更低的算法、是否解决了操作系统带来的性能损失（如上文的调度问题和内存缺页问题）、是否进行了正确高效的图优化等等。</p>
<p>由于影响因素很多，因此<strong>软件对性能的影响往往呈现出很强的非线性</strong>，导致在评估性能时很难给出一些普适性的结论，<strong>很多时候只能具体情况具体分析</strong>。</p>
<p>例如同样计算量的向量四则运算和超越函数，后者往往会慢于前者的原因是很多硬件不支持超越函数的 SIMD 指令；再比如空洞卷积（dilated Conv）性能会弱于普通卷积的原因是前者对访存的利用不如后者高效等等。</p>
<p>在软件实现的影响下，RoofLine 模型的上界再次下降，达到图中的红线（真实的非线性可能会比我随手画的要复杂的多）：</p>
<p><img src="/images/%E5%BD%B1%E5%93%8D%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0/image-20221202145852343.png" alt="image-20221202145852343"></p>
<p>RoofLine 模型各种性能损失示意图，图中曲线不代表真实比例</p>
<p>因此，在评估或分析深度学习推理性能时，简单的计算量/访存量指标是完全不够的，只能做个性能上界参考。实际能达到的性能其实还要关注很多很多因素，例如算子的访存模式、数据排布、是否能够进行图融合、是否有精度可接受的低时间复杂度算法、算法并行度是否充足、各种运算的比例等等因素。</p>
<p><strong>这些因素对于算法同学而言可能过于复杂，并不需要掌握。但如果所在的公司/部门有交流的机会的话，可以跟部署/优化的同学针对模型结构和算子进行探讨，以获取性能优化的建议。</strong></p>
<p>这里可以一些<strong>一般性的结论</strong>，仅供参考：</p>
<ul>
<li>对于一些访存非常密集且访存 pattern 连续的算子，如 Concat、Eltwise Sum、ReLU、LeakyReLU、ReflectionPad 等，在 Tensor 数据量很大的情况下，软件实现的损失会非常小，正常情况下基本都能达到内存带宽实测上限；如果框架采用了融合策略的话，基本可以达到 0 开销。</li>
<li>对于 Conv/FC/Deconv 等算子，在计算密度很高的情况下，大多数框架是能够很接近算力峰值的。但对于计算密度不是特别高的 case，不同框架的表现不一，需要实测才能确定。不过从大趋势而言，都是计算密度越高，硬件的利用率越高的。</li>
<li>尽量使用常用的算子参数，例如 Conv 尽量使用 3x3_s1/s2，1x1___s1/s2 等，这些常用参数往往会被特殊优化，性能更好。</li>
</ul>
<h3 id="4-小结-1"><a href="#4-小结-1" class="headerlink" title="4. 小结"></a><strong>4. 小结</strong></h3><p>RoofLine 模型仅能用于估计模型所能达到的性能上界，而实际部署时，还会受硬件限制、系统环境、软件实现等因素的影响，导致无法达到 RoofLine 模型所定义的性能上界。</p>
<p>此外，由于这些因素往往会导致性能曲线有较强的非线性，理论分析和实测会有一定差距，有时这些因素会严重影响性能曲线，甚至会导致算子的性质发生变化。因此本节讨论的内容只是提供一些分析的思路与技巧，<strong>实测始终是最准确的性能评估方式</strong>。</p>
<h2 id="四、面向推理速度的模型设计建议"><a href="#四、面向推理速度的模型设计建议" class="headerlink" title="四、面向推理速度的模型设计建议"></a><strong>四、面向推理速度的模型设计建议</strong></h2><p>前面讨论了一大堆，其实最实用的还是“怎么设计模型能够达到更快的推理速度”。</p>
<p>在给出我的个人建议之前，首先要先声明的是：由于不同硬件、不同环境、不同框架的差异会很大，这些建议可能并不是在所有条件下都适用。在设计算法或性能测试遇到疑问时，建议咨询部署/优化的同学。</p>
<p>好了，废话不多说（其实已经说了很多了），给出我的一些个人建议：</p>
<p><strong>方法论建议</strong>：</p>
<ul>
<li>了解目标硬件的峰值算力和内存带宽，最好是实测值，用于指导网络设计和算子参数选择。</li>
<li>明确测试环境和实际部署环境的差异，最好能够在实际部署环境下测试性能，或者在测试环境下模拟实际部署环境。</li>
<li>针对不同的硬件平台，可以设计不同计算密度的网络，以在各个平台上充分发挥硬件计算能力（虽然工作量可能会翻好几倍【捂脸）。</li>
<li>除了使用计算量来表示/对比模型大小外，建议引入访存量、特定平台执行时间，来综合反映模型大小。</li>
<li>实测是最准确的性能评估方式，如果有条件快速实测的话，建议以实测与理论分析相结合的方式设计并迭代网络。</li>
<li>遇到性能问题时，可以逐层 profiling，并与部署/优化同学保持紧密沟通，具体问题具体分析（适当了解一下计算相关理论的话，可以更高效的沟通）。</li>
</ul>
<p><strong>网络设计建议</strong>：</p>
<ul>
<li>对于低算力平台（CPU、低端 GPU 等），模型很容易受限于硬件计算能力，因此可以采用计算量低的网络来降低推理时间。</li>
<li>对于高算力平台（GPU、DSP 等），一味降低计算量来降低推理时间就并不可取了，往往更需要关注访存量。单纯降低计算量，很容易导致网络落到硬件的访存密集区，导致推理时间与计算量不成线性关系，反而跟访存量呈强相关（而这类硬件往往内存弱于计算）。相对于低计算密度网络而言，高计算密度网络有可能因为硬件效率更高，耗时不变乃至于更短。</li>
<li>面向推理性能设计网络结构时，尽量采用经典结构，大部分框架会对这类结构进行图优化，能够有效减少计算量与访存量。例如 Conv-&gt;BN-&gt;ReLU 就会融合成一个算子，但 Conv-&gt;ReLU-&gt;BN 就无法直接融合 BN 层</li>
<li>算子的参数尽量使用常用配置，如 Conv 尽量使用 3x3_s1/s2、1x1___s1/s2 等，软件会对这些特殊参数做特殊优化。</li>
<li>CNN 网络 channel 数尽量选择 4/8/16/32 的幂次，很多框架的很多算子实现在这样的 channel 数下效果更好（具体用多少不同平台不同框架不太一样）。</li>
<li>框架除了计算耗时外，也处理网络拓扑、内存池、线程池等开销，这些开销跟网络层数成正比。因此相比于“大而浅”的网络，“小而深”的网络这部分开销更大。一般情况下这部分开销占比不大。但在网络算子非常碎、层数非常多的时候，这部分开销有可能会影响多线程的扩展性，乃至于成为不可忽视的耗时因素。</li>
</ul>
<p><strong>一些其他建议</strong>：</p>
<ul>
<li>除了优化网络结构、推理框架性能外，还可以考虑通过一些其他工程技巧来提升系统整体的性能。例如：对推理服务流水化，并行数据读取与计算的过程，掩盖 IO 延时。</li>
</ul>
<p>本文介绍了评估模型大小的四个常用指标——计算量、参数量、访存量、内存占用，从 RoofLine 模型入手详细讨论了影响模型推理速度的影响因素，并给出了面向推理速度的模型设计方法论与建议。</p>
<p>撰写本文的目的，不仅仅是给算法同学提供有效的网络设计建议，更多的还是希望能够传达性能优化的基础知识与分析思路，减少算法设计到部署之间的 gap，更快速高效的设计推理友好的网络模型。希望能对大家的工作有所帮助。</p>
<p>看到评论区有人问有没有访存量小的模型结构。一些研究工作，例如 ShuffleNetV2， 已经在设计网络的时候兼顾访存量了。但据我所知目前还没有像 DepthWise Conv 一样经典的节省访存量的模型结构。</p>
<p>关于这个问题，我个人是这么看的：</p>
<ul>
<li>访存量可以减小，但网络精度很难保证不变，因此需要一系列的研究来探索</li>
<li>一些白给访存量的技巧可以用上，一些白白浪费访存量的操作不要搞</li>
<li>低精度/量化有的时候节省访存量的意义远大于节省计算量</li>
</ul>
<p>回顾 Xception/ MobileNet 的研究就可以看出，DWConv 3X3 + Conv 1X1 的结构之所以成为经典结构，一方面是计算量确实减少了，另一方面也是其精度确实没有太大的损失。计算量可以在设计完网络时就可以算出，但网络精度只有在网络训练完之后才能评估，需要花费大量的时间与精力反复探索才能找到这一结构。</p>
<p>一些研究确实开始关注访存量对推理速度的影响，例如 ShuffleNetV2 在选定 group 的时候就是以访存量为依据的，但并不是整体的 block 都是围绕降低访存量来设计的。由于本人很久没有关注算法的研究进展了，据我所知目前是没有专注于减少放存量的模型结构及研究工作的（如果有的话欢迎在评论区留言）。</p>
<p>我个人认为这可以成为一个很好的研究主题，可以为模型部署带来很大的帮助。一种方法是可以通过手工设计网络结构，另一种方法是可以将访存量作为 NAS 的一个参数进行搜索。前者可解释性更强一些，后者可能研究起来更容易。但是有一点请务必注意：<strong>降低访存量的最终目的一定是为了减少模型的推理时间</strong>。如果模型处在目标设备的计算密集区，降低访存量的意义有限。</p>
<p>关于实际工程部署，有一些技巧/注意的点可以保证不浪费访存量：</p>
<ul>
<li>channel 数尽量保持在 4/8/16/32 的倍数，不要设计 channel = 23 这种结构。目前大部分推理框架为了加速计算，都会用特殊的数据排布，channel 会向上 pad。比如框架会把 channel pad 到 4 的倍数，那么 channel = 23 和 24 在访存量上其实是一致的。</li>
<li>一些非常细碎乃至毫无意义的后处理算子，例如 Gather、Squeeze、Unsqueeze 等，最好给融合掉。这种现象往往见于 PyTorch 导出 onnx 的时候，可以尝试使用 onnxsim 等工具来进行融合，或者手动添加大算子。</li>
<li>尝试一些部署无感的技巧，例如蒸馏、RepVGG等。</li>
</ul>
<p>最后想聊一下低精度/量化。对于设备算力很强但模型很小的情况，低精度/量化我个人认为其降低访存量的作用要远大于节省计算量，可以有效加快模型推理速度。但是要注意两点：一个是框架如果不支持 requant，而是每次计算前都量化一次，计算完之后再反量化，那么使用低精度/量化反而会增加访存量，可能造成推理性能的下降；另一个是对于支持混合精度推理的框架，要注意不同精度转换时是否会有额外的性能开销。如果有的话，要尽量减少精度的转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 请问例如conv-relu-conv这样的结构，特征的内存访问是2次、4次还是6次呢?</span><br><span class="line">我们一般会把 conv-&gt;bn-&gt;relu 合并成一个算子，这样特征图是读一次写一次</span><br><span class="line">conv_with_relu -&gt; conv_with_relu 这样的结构的话，大部分实现的特征图是两读两写，但是有些实现会把这两个算子再融合起来，变成conv_with_relu_with_conv_with_relu，这样特征图就是一读一写了.</span><br><span class="line">2. 关于访存量的计算，一般都是 sizeof(parameter) + sizeof(output feature map)吧？</span><br><span class="line">从网络整体来看，访存量确实只有 sizeof(param) + sizeof(input tensor) + sizeof(output tensor)。但是框架在实现网络推理时，一般都是一个 op 一个 op 来的，所以中间的 feature map 的读写也要考虑进去。</span><br><span class="line">不过中间的 feature map 如果不大的话，是可以 hold 在 cache 里的，这就会导致在估算时使用的带宽其实应当比内存实测带宽稍大一些的</span><br><span class="line">3. 蒸馏、RepVGG为什么是部署无感的技巧呢？</span><br><span class="line">这两个方法都是在训练的时候会增加计算量， 但是实际部署的时候没有影响</span><br></pre></td></tr></table></figure>
<h3 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5. Reference"></a>5. Reference</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/411522457">https://zhuanlan.zhihu.com/p/411522457</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yukai.tech/2022/11/02/Tmux%E5%B1%8F%E5%B9%95%E5%86%85%E5%AE%B9%E8%BE%93%E5%87%BA%E8%87%B3%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="yukai">
      <meta itemprop="description" content="yukai的Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukai's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/02/Tmux%E5%B1%8F%E5%B9%95%E5%86%85%E5%AE%B9%E8%BE%93%E5%87%BA%E8%87%B3%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Tmux屏幕内容输出至文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-02 15:13:22 / 修改时间：15:30:59" itemprop="dateCreated datePublished" datetime="2022-11-02T15:13:22+08:00">2022-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/" itemprop="url" rel="index"><span itemprop="name">deep learning</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/object-detection/" itemprop="url" rel="index"><span itemprop="name">object detection</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/object-detection/OCR/" itemprop="url" rel="index"><span itemprop="name">OCR</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/object-detection/OCR/Video-Recognition/" itemprop="url" rel="index"><span itemprop="name">Video Recognition</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/object-detection/OCR/Video-Recognition/opencv/" itemprop="url" rel="index"><span itemprop="name">opencv</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>保存Tmux的屏幕输出分为两步： 首先用<code>capture-pane</code>将屏幕输出保存在buffer里， 然后用<code>save-buffer</code>将buffer内容保存到文件里。</p>
<p>在<code>capture-pane</code>中可以用<code>-S</code>和<code>-E</code>指定要保存的屏幕输出的范围， 当前屏幕的最上一行为坐标原点，标记为0，下面一行坐标是1,依次类推； 原点的上一行坐标是-1，再上一行坐标是-2，依次类推。</p>
<p>用<code>Alt-c</code>进入copy-mode后，屏幕右上角显示当前屏幕在整个pane中的坐标[X/Y]， 其中X代表当前屏幕最高行的坐标，Y代表最早一行屏幕输出的坐标， 根据坐标确定要保存文本的起止坐标就可以保存了。</p>
<p>例如要保存第3个pane中的一段近5000行的输出， 进入copy-mode后按<code>g</code>键，到最早的屏幕输出，右上角显示<code>[5676/5676]</code>, 用<code>Ctrl-f</code>或者<code>J</code>键向下滚动屏幕， 当想要保存的第一行处于屏幕最上一行时，坐标显示为<code>[5557/5676]</code>， 将想要保存的最后一行滚动到屏幕最上一行，坐标显示为<code>[642/5676]</code>， 切换到另一个pane里执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmux capture-pane -S -5557 -E -642 -t 3</span><br><span class="line">tmux save-buffer output.log</span><br></pre></td></tr></table></figure>
<p>这样这段输出就保存到文件output.log里了，其中<code>-t 3</code>指定了要保存的pane的序号。</p>
<p>如果要保存所有历史输出，可以简写为<code>tmux capture-pane -S -</code>.</p>
<p>除了新开一个pane执行tmux命令，也可以在当前pane用快捷键<code>Alt-a</code>进入tmux命令行状态 即command-prompt，然后执行<code>capture-pane -S -5557 -E -642</code>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yukai"
      src="/images/icon.jpg">
  <p class="site-author-name" itemprop="name">yukai</p>
  <div class="site-description" itemprop="description">yukai的Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wyukai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wyukai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yukai</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
